# このディレクトリーはvibe-kanbanの運用ルールを定義します

# 前提
- 実装して動かすことよりも設計を重視します。設計もまた品質の高い設計を最初から行うことを重視します。
- エージェントのアウトプットが十分予測可能になるまで事前のカードの内容を具体化して進めます
- 実装はエージェントが行いますが、エンジニアがコードを100%理解しながら進めることを要求します。
- つまりvibeコーディングの逆を行います

# 基本的な流れ
Epic -> Objective -> Spec(MRC) -> Micro(LM)

# 説明
各段階に分割する際に、同時にレビュー用のカードを作成してください。
レビューにより修正点があった場合は設計内容を修正していきます。

## Epic
- 最上位のカード
- なぜやるか?とやりたいことを記述する
- ユーザー価値につながるものはユーザーストーリーを記述する
- プロダクト価値につながるものはその説明を記述する(パフォーマンス改善、計測可能性の改善、コードの複雑さの低減など)
- タイトル: [Epic] Epicの内容
- OUTPUT Objectiveカードを作成する

### 含む内容
1. Why（なぜやるか）
2. What（やりたいこと）
3. ユーザー価値 or プロダクト価値

### 含めない内容
以下は Epic では扱わず、後続のカードで詳細化する：
- データモデル設計 → Objective で設計
- API設計 → Objective で設計
- UI実装詳細 → Spec で設計
- コード例 → Spec/Micro で実装

### 分量の目安
- 全体で500-1,000文字
- 読了時間2-3分

## Objective
- Epicに紐づく、上流設計粒度のカード
  - 多くの場合はEpicと1対1で済むので無理して分けなくていい
- カードに設計内容を記述する。このカードの時点で設計の妥当性を判断できる程度に詳細化すること
- タイトル: [Objective] Objectiveの内容
- OUTPUT Specカードを作成する

### 含む内容
1. ゴールと背景（何を実現したいか、なぜ必要か）
2. ドメインモデル設計（ビジネスロジック、エンティティ間の関係）
3. **データ項目の洗い出し**
   - 追加・変更するテーブルと項目一覧
   - 各項目の用途、取りうる値、NULL許容
   - 外部キー関係
4. **UI要素の洗い出し**
   - 追加・変更する画面とUI要素一覧
   - 各要素の種類、表示条件、動作
5. API機能要件（どんなエンドポイントが必要か）
6. 技術的な制約や前提条件

### 含めない内容
以下は Objective では扱わず、後続のカードで詳細化する：
- 具体的な型定義、制約、インデックス設計 → Spec で設計
- 具体的なSQL、コード例 → Spec で設計
- 具体的なコンポーネント実装、状態管理 → Spec で設計
- 変数名の決定 → Spec で設計

### 分量の目安
- 全体で1,500-2,500文字
- 読了時間3-5分


## Spec
- Objectiveに紐づく、詳細設計の粒度
- 開発タスクにおいてはMRCとなる大きさでPRを作成する粒度
- インフラ、アーキテクチャレベルの意思決定はここで行う
- **コードが自明になる程度の設計を記述する（コードそのものは書かない）**
- **エージェントの質に依らず、同じ実装に収束するような設計意図を明確にする**
- 具体的にどのクラスにどのような振る舞いを追加するのかわかる程度に具体化する
- UI要素であれば、どのような要素が追加されるのか?どのように追加されるのか(縦方向に並ぶなど)?振る舞いがある場合はどのような振る舞いか?を具体的に記述する
- OUTPUT Microカードを作成する

### 含む内容
1. スコープ（このSpecで何を実装するか）
2. **データモデル設計**
   - 各カラム/フィールドの型、制約、インデックスの必要性
   - **命名規則と変数名（日英対応、ケース規則）**
   - 設計意図（なぜこの設計にしたか）
   - マイグレーション戦略
3. **API設計**
   - エンドポイント、メソッド、パス
   - リクエスト/レスポンスの構造と型
   - **フィールド名（統一された命名）**
   - エラーハンドリングの方針
4. **UI設計**
   - UI要素の種類、配置、動作
   - **state変数名、form属性名**
   - **ラベルテキスト（日英）**
   - 状態管理の方針
   - バリデーション、表示条件
5. **技術的制約と前提条件**
6. **受け入れ基準**（テストケース相当）

### 含めない内容
以下は Spec では扱わず、実装時にエージェントが判断する：
- 具体的なSQL文（設計から自明にする）
- 具体的なコード例（設計から自明にする）
- 実装パターンの詳細（エージェントに任せる）
- ライブラリの詳細な使い方（エージェントが選択）

### 記述の原則
- **What（何を）+ Why（なぜ）+ 制約** を記述
- **命名の一貫性を保証する**（DB/Rust/TypeScript で統一）
- コードではなく**設計意図**を伝える
- 新しいエージェントでも同じ設計に収束するように書く

### 命名規則の記述方法
概念と変数名の対応を明示する：

**推奨フォーマット（表形式）:**
```markdown
| 概念（日本語） | DB | Rust | TypeScript | UI Label (EN/JP) |
|----------------|-----|------|------------|------------------|
| タスク階層レベル | task_level | task_level | taskLevel | Task Level / タスクレベル |
| 親タスクID | parent_task_id | parent_task_id | parentTaskId | Parent Task / 親タスク |
```

### 分量の目安
- 全体で2,000-3,000文字
- 読了時間5-10分


## Micro
Microは実務を担当する。
- Codingタスク
  - Specに紐づく開発、実装タスクの粒度
  - レビューの認知不可を下げるために、1ファンクション単位、インターフェース追加程度の粒度で作成する
  - カードの記述内容だけで実装内容が完全にわかるくらい詳細に記述する
  - 例えばUI(HTML)要素であれば、まず縦方向に深くn段階掘るカードを1つ、同じ深さで横に並べるためのカードを1つ程度の詳細さ
  - Small-CLを意識し、コード変更は20行以下、1ファイルを目安とする

- Researchタスク
  - 技術調査、インターネット情報の調査が必要なタスク
  - 情報の整理をしたうえで、根拠を元にドキュメント化を行う
  - アウトプットはマークダウンに記述し、日本語にすること
- Documentationタスク
  - ドキュメンテーション全般を担う
  - アウトプットはマークダウンに記述し、日本語にすること

### 分量の目安
- 全体で300-500文字
- 1機能、1ファイル、20行以下のコード変更

# その他カードテンプレート
## Epicレビュー
Epicの内容の妥当性を検証する
何をやりたいかわかるか?
ユーザー価値が実現できそうか?
ユーザー価値は妥当が?
解決策の筋はよさそうか?
システムが複雑になりすぎないか?
基本的に機能は増やさないほうがシステムにとってはポジティブであることを忘れずに。

Epicとその配下のObjectiveをレビューし、設計上問題ないかレビューする。エンジニアと、よりよい設計ができないか?議論する。
エンジニアからの指示があれば、Epicカードの書き換えと、Objectiveカードの編集を行う。

### フィードバック時の対応
修正が必要な場合：
1. Epicカードを修正
2. 既存のObjectiveカードを削除（影響範囲に応じて）
3. 修正したEpicから新しいObjectiveを生成

## Objectiveレビュー
Objectiveカードの内容をレビューする
Epicの目的を達成できているか?
設計が妥当か?
技術的課題はないか?
低品質な設計になっていないか?
複雑すぎる設計になっていないか?
運用が難しい設計になっていないか?
Specカードがある場合は、あわせてレビューする
必要であればエンジニアの承認を得たうえで再設計を行いカードを修正する

Objectiveとその配下のSpecをレビューし、設計上問題ないかレビューする。エンジニアと、よりよい設計ができないか?議論する。
エンジニアからの指示があれば、Objectiveカードの書き換えと、Specカードの編集を行う。

### フィードバック時の対応
修正が必要な場合：
1. Objectiveカードを修正
2. 既存のSpecカードを削除（影響範囲に応じて）
3. 修正したObjectiveから新しいSpecを生成

Epicの見直しが必要な場合：
→ Epicレビューに戻り、Epic修正後にObjectiveを再生成

## Specレビュー
Specカードの内容をレビューする
Objectiveの設計と整合しているか?
技術的課題はないか?
低品質な設計になっていないか?
複雑すぎる設計になっていないか?
運用が難しい設計になっていないか?
Microカードがある場合は、あわせてレビューする
必要であればエンジニアの承認を得たうえで再設計を行いカードを修正する

SpecとMicroで作成したコードをレビューし、設計上問題ないかレビューする。エンジニアと、よりよい設計ができないか?議論する。
エンジニアからの指示があれば、Specカードの書き換えと、Microカードの編集を行う。

### フィードバック時の対応
修正が必要な場合：
1. Specカードを修正
2. 影響を受けるMicroカードを削除
3. 修正したSpecから新しいMicroを生成

Objectiveの見直しが必要な場合：
→ Objectiveレビューに戻り、Objective修正後にSpecを再生成


# AIエージェント
## Epic_Planner
入力: Epicカード
出力: 実現方法を検討し、上流設計を行い、結果をEpicカードへ反映する
Objectiveカードを作成する
Epicレビューカードを作成する
実装は行わない


## Objective_Planner
入力: Objectiveカード
出力: 実現方法を検討し、詳細設計を行い、結果をObjectiveカードへ反映する
Specカードを作成する
Objectiveレビューカードを作成する
実装は行わない

## Spec_Planner
入力: Specカード
出力: 実現方法を検討し、詳細な実装内容を設計し、結果をSpecカードへ反映する
Microカードを作成する
Specレビューカードを作成する
実装は行わない

## Coder
Microの実装タスクを割り当てる制約違反は失敗で返す。

## Researcher
MicroのResearchタスクを割り当てる。技術検証、調査が必要なタスクを担当する

## Doc_Writer
MicroのDocumetationタスクを割り当てる。

## Reviewer
レビュータスクを担当。設計に技術的問題がないか、低品質な設計になっていないかをレビューする
レビュー対象のカードの更新内容を提案する


## カード管理ルール

### カードの構造
- Epic/Objective/Spec/Microは**それぞれ独立したカード**として作成
- 各カードの冒頭に親階層の情報を明記

### 親子関係の記載フォーマット
**親Epic**: [Epic名] (ID: `xxxxx`)
**親Objective**: [Objective名] (ID: `xxxxx`)
**親Spec**: [Spec名] (ID: `xxxxx`)

### タイトル命名規則
- Epic: `[Epic] 機能名`
- Objective: `[Objective] 設計名`
- Spec: `[Spec] 詳細設計名`
- Micro: `[Micro] 実装タスク名`
- 作成タスク: `Make [階層] [対象名]`
