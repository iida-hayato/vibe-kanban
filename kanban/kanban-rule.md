# このディレクトリーはvibe-kanbanの運用ルールを定義します

# 前提
- 実装して動かすことよりも設計を重視します。設計もまた品質の高い設計を最初から行うことを重視します。
- エージェントのアウトプットが十分予測可能になるまで事前のカードの内容を具体化して進めます
- 実装はエージェントが行いますが、エンジニアがコードを100%理解しながら進めることを要求します。
- つまりvibeコーディングの逆を行います

# 基本的な流れ
Epic -> Objective -> Spec(MRC) -> Micro(LM)

# 説明
各段階に分割する際に、同時にレビュー用のカードを作成してください。
レビューにより修正点があった場合は設計内容を修正していきます。

## Epic
- 最上位のカード
- なぜやるか?とやりたいことを記述する
- ユーザー価値につながるものはユーザーストーリーを記述する
- プロダクト価値につながるものはその説明を記述する(パフォーマンス改善、計測可能性の改善、コードの複雑さの低減など)
- タイトル: [Epic] Epicの内容
- OUTPUT Objectiveカードを作成する

### 含む内容
1. **Why（なぜやるか）**
   - 背景（現状の説明）
   - 現状の問題（箇条書き）
   - 影響（問題による悪影響）
   - **なぜ今やるのか**（タイミング・優先度の理由）
   - ユーザーストーリー（該当する場合のみ）
     - フォーマット: 「[ペルソナ]として、[やりたいこと]が欲しい。なぜなら、[理由]。」
   - ユーザー価値 or プロダクト価値
     - できれば測定可能な形で記述

2. **What（やりたいこと）**
   - コンセプト（一文での要約）
   - 実現したいこと（主要機能を3-5項目で列挙）
   - 期待される効果
   - **スコープ外**（やらないこと、Phase分けの説明）
   - **トレードオフ**（実装コスト vs 効果、諦めること）

3. **他のEpicとの関係**
   - **依存関係**
     - 必須の前提条件（ブロッカー）
     - 推奨される実装順序
     - ブロックされるEpic
   - **リスクと対策**（任意だが推奨）
     - 技術リスク → 対策
     - UXリスク → 対策
     - スコープリスク → 対策

4. **成功指標**
   - 機能面（実装完了の判断基準）
   - UX面（ユーザー体験の改善指標）
   - プロダクト面（プロダクト全体への貢献）

### 含めない内容
以下は Epic では扱わず、後続のカードで詳細化する：
- データモデル設計 → Objective で設計
- API設計 → Objective で設計
- UI実装詳細 → Spec で設計
- コード例 → Spec/Micro で実装
- Phase分けの詳細実装計画 → Objective/Spec で詳細化
- 技術的選択肢の詳細比較 → Objective で検討
- 参考ファイルリスト → Objective/Spec で記載

### 記述の原則
- **問題→影響→価値→解決策** の流れで書く
- **具体的な実装には踏み込まない**（「何を」は書くが「どう」は書かない）
- **トレードオフを明示する**（何を得て、何を諦めるか）
- **リスクを先回りする**（うまくいかない場合の対策）
- **測定可能な成功指標を設定する**（可能な限り数値目標）

### 分量の目安
- 基本: 500-1,000文字
- 拡張版（リスク・トレードオフ含む）: 1,000-1,500文字
- 読了時間2-3分

### テンプレート例

```markdown
# Epic: [タイトル]

## 🎯 Why（なぜやるか）

### 背景
[現状の説明]

**現状の問題:**
- [問題1]
- [問題2]
- [問題3]

**影響:**
- [影響1]
- [影響2]

### なぜ今やるのか
- [タイミングの理由]
- [優先度の理由]
- [他の機能との関連]

### ユーザーストーリー（該当する場合）
**[ペルソナ]として、**
[やりたいこと]が欲しい。
なぜなら、[理由]。

### ユーザー価値 or プロダクト価値
- ✅ [価値1（できれば測定可能な形で）]
- ✅ [価値2]
- ✅ [価値3]
```


## Objective
- Epicに紐づく、上流設計粒度のカード
  - 多くの場合はEpicと1対1で済むので無理して分けなくていい
- カードに設計内容を記述する。このカードの時点で設計の妥当性を判断できる程度に詳細化すること
- タイトル: [Objective] Objectiveの内容
- OUTPUT Specカードを作成する

### 含む内容
1. ゴールと背景（何を実現したいか、なぜ必要か）
2. **ドメインモデリング**
   - エンティティ、値オブジェクト
   - エンティティ間の関係
   - ライフサイクル
   - ビジネスルール
3. **永続化が必要なエンティティ**（概要）
   - どのエンティティを永続化するか
   - 主要な関係性
   - （項目詳細は Spec で）
4. UI機能要件（どんな画面・機能が必要か）
5. API機能要件（どんなエンドポイントが必要か）
6. 技術的な制約や前提条件

### 含めない内容
以下は Objective では扱わず、後続のカードで詳細化する：
- 具体的な型定義、制約、インデックス設計 → Spec で設計
- 具体的なSQL、コード例 → Spec で設計
- 具体的なコンポーネント実装、状態管理 → Spec で設計
- 変数名の決定 → Spec で設計

### 分量の目安
- 全体で1,500-2,500文字
- 読了時間3-5分


## Spec
- Objectiveに紐づく、詳細設計の粒度
- **開発タスクにおいてはMRCとなる大きさでPRを作成する粒度**
- **1つのSpecは1つの責務・1つの層に集中する**
- インフラ、アーキテクチャレベルの意思決定はここで行う
- **コードが自明になる程度の設計を記述する（コードそのものは書かない）**
- **エージェントの質に依らず、同じ実装に収束するような設計意図を明確にする**
- 具体的にどのクラスにどのような振る舞いを追加するのかわかる程度に具体化する
- UI要素であれば、どのような要素が追加されるのか?どのように追加されるのか(縦方向に並ぶなど)?振る舞いがある場合はどのような振る舞いか?を具体的に記述する
- OUTPUT Microカードを作成する

### Specの粒度原則

**基本原則:**
**1つのSpecは1つの責務・1つの層に集中する。**

異なる責務や層にまたがる場合は、必ず別々のSpecに分割する。

**一般的な層の例：**

1. **ドメイン層**
   - ビジネスロジック、エンティティ、値オブジェクト、ドメインサービス
   - 例: TaskLevel値オブジェクト実装、タスク階層検証ロジック

2. **データ層（永続化）**
   - テーブル、スキーマ、マイグレーション、リポジトリ
   - 例: tasksテーブル拡張、TaskRepositoryインターフェース

3. **アプリケーション層**
   - API、ユースケース、アプリケーションサービス、トランザクション
   - 例: タスク作成API、CreateTaskUseCase実装

4. **プレゼンテーション層**
   - UI、コンポーネント、画面、ビューモデル
   - 例: TaskFormDialog拡張、TaskCardバッジ表示

5. **インフラ層**
   - 外部サービスクライアント、キャッシュ、ストレージ、メッセージング
   - 例: NotificationServiceクライアント、Redisキャッシュ実装

6. **契約層**
   - 外部API定義、イベントスキーマ、プロトコル定義
   - 例: OpenAPI定義、gRPCサービス定義、WebSocketイベント仕様

**プロジェクト固有の層:**
上記以外にも、プロジェクトによって以下のような層が存在する場合がある：
- セキュリティ層（認証、認可）
- 監視層（メトリクス、トレーシング）
- バッチ処理層
- その他のアーキテクチャ固有の層

**これらも同様に、1つの層・1つの責務ごとに1つのSpecとする。**

### 分割の判断基準

以下のいずれかに該当する場合、別Specに分割する：
- ✅ 異なる層にまたがる（Domain + Data など）
- ✅ 異なる責務を持つ（CRUD + バリデーション など）
- ✅ 1PR に収まらない
- ✅ レビュー時間が30分を超える
- ✅ 複数のファイル/モジュールに大きな変更

### 良い例・悪い例

**❌ 悪い例（複数の層にまたがる）:**
```
Spec: タスク階層機能の実装
- TaskLevel値オブジェクト（ドメイン層）
- tasksテーブル拡張（データ層）
- タスク作成API（アプリケーション層）
- TaskFormDialog拡張（プレゼンテーション層）
```

**✅ 良い例（層ごとに分割）:**
```
Spec 1: TaskLevel値オブジェクト実装（ドメイン層）
Spec 2: tasksテーブル拡張（データ層）
Spec 3: タスク作成API拡張（アプリケーション層）
Spec 4: TaskFormDialog拡張（プレゼンテーション層）
```

### 迷った場合の判断方法

**「このSpecは1文で説明できるか？」**
- Yes → 適切な粒度
- No → 分割を検討

**「このSpecのレビューで複数の観点が必要か？」**
- ドメインロジックとDB設計の両方 → 分割
- APIとUIの両方 → 分割
- 1つの観点のみ → OK

### 含む内容（1つのSpecあたり）
1. スコープ（このSpecで何を実装するか）
2. **以下のいずれか1つに集中**：
   
   **a. ドメイン層**（ビジネスロジックの場合）
   - エンティティの振る舞い（メソッド）
   - 値オブジェクトの定義と振る舞い
   - ドメインサービスのロジック
   - ビジネスルールの実装方針
   - 不変条件（Invariant）
   - ドメインイベント（必要な場合）
   
   **b. データ層**（永続化の場合）
   - テーブル/コレクション設計
   - 項目詳細（型、制約、NULL許容）
   - 命名規則（日英対応、ケース規則）
   - インデックス設計
   - マイグレーション戦略
   - リポジトリインターフェース（必要な場合）
   
   **c. アプリケーション層**（API/ユースケースの場合）
   - エンドポイント（メソッド、パス）
   - ユースケースの実装方針
   - リクエスト/レスポンス構造
   - フィールド名（統一された命名）
   - バリデーション
   - エラーハンドリング
   
   **d. プレゼンテーション層**（UIの場合）
   - コンポーネント構造
   - state変数名、props、イベント
   - ラベルテキスト（日英）
   - 表示条件、バリデーション
   - ユーザーフロー
   
   **e. インフラ層**（外部サービス等の場合）
   - 外部サービスクライアントの実装方針
   - キャッシュ戦略
   - ストレージ設計
   - メッセージング設計
   
   **f. 契約層**（外部インターフェースの場合）
   - API定義（OpenAPI/gRPC等）
   - イベントスキーマ
   - プロトコル仕様
   
   **g. その他の層**
   - プロジェクト固有の層も同様に、1層1Specの原則で設計

3. **技術的制約と前提条件**
4. **受け入れ基準**

### 含めない内容
以下は Spec では扱わず、実装時にエージェントが判断する：
- 具体的なSQL文（設計から自明にする）
- 具体的なコード例（設計から自明にする）
- 実装パターンの詳細（エージェントに任せる）
- ライブラリの詳細な使い方（エージェントが選択）

### 記述の原則
- **What（何を）+ Why（なぜ）+ 制約** を記述
- **命名の一貫性を保証する**（DB/Rust/TypeScript で統一）
- **1つの関心事に集中する**（Single Responsibility）
- コードではなく**設計意図**を伝える
- 新しいエージェントでも同じ設計に収束するように書く

### 命名規則の記述方法
概念と変数名の対応を明示する：

**推奨フォーマット（表形式）:**
```markdown
| 概念（日本語） | DB | Rust | TypeScript | UI Label (EN/JP) |
|----------------|-----|------|------------|------------------|
| タスク階層レベル | task_level | task_level | taskLevel | Task Level / タスクレベル |
| 親タスクID | parent_task_id | parent_task_id | parentTaskId | Parent Task / 親タスク |
```

### 分量の目安
- **ドメイン層Spec**: 800-1,200文字
- **データ層Spec**: 1,000-1,500文字
- **アプリケーション層Spec**: 800-1,200文字
- **プレゼンテーション層Spec**: 1,000-1,500文字
- **インフラ層・契約層Spec**: 800-1,200文字
- 読了時間3-5分
- **1つのObjectiveから通常4-12個のSpecを作成する**


## Micro
Microは実務を担当する。
- Codingタスク
  - Specに紐づく開発、実装タスクの粒度
  - レビューの認知不可を下げるために、1ファンクション単位、インターフェース追加程度の粒度で作成する
  - カードの記述内容だけで実装内容が完全にわかるくらい詳細に記述する
  - 例えばUI(HTML)要素であれば、まず縦方向に深くn段階掘るカードを1つ、同じ深さで横に並べるためのカードを1つ程度の詳細さ
  - Small-CLを意識し、コード変更は20行以下、1ファイルを目安とする

- Researchタスク
  - 技術調査、インターネット情報の調査が必要なタスク
  - 情報の整理をしたうえで、根拠を元にドキュメント化を行う
  - アウトプットはマークダウンに記述し、日本語にすること
- Documentationタスク
  - ドキュメンテーション全般を担う
  - アウトプットはマークダウンに記述し、日本語にすること

### 分量の目安
- 全体で300-500文字
- 1機能、1ファイル、20行以下のコード変更

# その他カードテンプレート
## Epicレビュー
Epicの内容の妥当性を検証する
何をやりたいかわかるか?
ユーザー価値が実現できそうか?
ユーザー価値は妥当が?
解決策の筋はよさそうか?
システムが複雑になりすぎないか?
基本的に機能は増やさないほうがシステムにとってはポジティブであることを忘れずに。

Epicとその配下のObjectiveをレビューし、設計上問題ないかレビューする。エンジニアと、よりよい設計ができないか?議論する。
エンジニアからの指示があれば、Epicカードの書き換えと、Objectiveカードの編集を行う。

### フィードバック時の対応
修正が必要な場合：
1. Epicカードを修正
2. 既存のObjectiveカードを削除（影響範囲に応じて）
3. 修正したEpicから新しいObjectiveを生成

## Objectiveレビュー
Objectiveカードの内容をレビューする
Epicの目的を達成できているか?
設計が妥当か?
技術的課題はないか?
低品質な設計になっていないか?
複雑すぎる設計になっていないか?
運用が難しい設計になっていないか?
Specカードがある場合は、あわせてレビューする
必要であればエンジニアの承認を得たうえで再設計を行いカードを修正する

Objectiveとその配下のSpecをレビューし、設計上問題ないかレビューする。エンジニアと、よりよい設計ができないか?議論する。
エンジニアからの指示があれば、Objectiveカードの書き換えと、Specカードの編集を行う。

### フィードバック時の対応
修正が必要な場合：
1. Objectiveカードを修正
2. 既存のSpecカードを削除（影響範囲に応じて）
3. 修正したObjectiveから新しいSpecを生成

Epicの見直しが必要な場合：
→ Epicレビューに戻り、Epic修正後にObjectiveを再生成

## Specレビュー
Specカードの内容をレビューする
Objectiveの設計と整合しているか?
技術的課題はないか?
低品質な設計になっていないか?
複雑すぎる設計になっていないか?
運用が難しい設計になっていないか?
Microカードがある場合は、あわせてレビューする
必要であればエンジニアの承認を得たうえで再設計を行いカードを修正する

SpecとMicroで作成したコードをレビューし、設計上問題ないかレビューする。エンジニアと、よりよい設計ができないか?議論する。
エンジニアからの指示があれば、Specカードの書き換えと、Microカードの編集を行う。

### フィードバック時の対応
修正が必要な場合：
1. Specカードを修正
2. 影響を受けるMicroカードを削除
3. 修正したSpecから新しいMicroを生成

Objectiveの見直しが必要な場合：
→ Objectiveレビューに戻り、Objective修正後にSpecを再生成


# AIエージェント
## Epic_Planner
入力: Epicカード
出力: 実現方法を検討し、上流設計を行い、結果をEpicカードへ反映する
Objectiveカードを作成する
Epicレビューカードを作成する
実装は行わない


## Objective_Planner
入力: Objectiveカード
出力: 
  - 実現方法を検討し、詳細設計を行い、結果をObjectiveカードへ反映する
  - **Specカードを複数作成する**
    - 1つのObjectiveから通常4-12個のSpec
    - 各Specは1つの層（Domain/Data/API/UI等）に集中
    - **異なる層や責務は必ず別々のSpecとして作成**
  - Objectiveレビューカードを作成する
  
実装は行わない

### Spec作成の原則
- 各Specは1PR（MRC）に収まる粒度
- **各Specは1つの層・1つの責務に集中**
- 異なる層や責務にまたがる場合は必ず分割

### 層の例
以下は一般的な層の例。プロジェクトによって異なる層がある場合も同様に扱う：
- ドメイン層（ビジネスロジック、エンティティ、値オブジェクト）
- データ層（永続化、テーブル、リポジトリ）
- アプリケーション層（API、ユースケース、アプリケーションサービス）
- プレゼンテーション層（UI、コンポーネント、画面）
- インフラ層（外部サービス、キャッシュ、ストレージ）
- 契約層（API定義、イベントスキーマ）

### Spec作成例

1つのObjectiveから通常4-12個のSpecを作成：

**ドメイン層:**
- 値オブジェクト実装
- エンティティ振る舞い追加
- ドメインサービス実装

**データ層:**
- テーブル追加/変更
- マイグレーション

**アプリケーション層:**
- ユースケース実装
- API エンドポイント追加/変更

**プレゼンテーション層:**
- コンポーネント追加/変更
- 画面実装

**その他の層:**
プロジェクト固有の層も同様に、1層1Specの原則で作成する。

## Spec_Planner
入力: Specカード
出力: 実現方法を検討し、詳細な実装内容を設計し、結果をSpecカードへ反映する
Microカードを作成する
Specレビューカードを作成する
実装は行わない

## Coder
Microの実装タスクを割り当てる制約違反は失敗で返す。

## Researcher
MicroのResearchタスクを割り当てる。技術検証、調査が必要なタスクを担当する

## Doc_Writer
MicroのDocumetationタスクを割り当てる。

## Reviewer
レビュータスクを担当。設計に技術的問題がないか、低品質な設計になっていないかをレビューする
レビュー対象のカードの更新内容を提案する


## カード管理ルール

### カードの構造
- Epic/Objective/Spec/Microは**それぞれ独立したカード**として作成
- 各カードの冒頭に親階層の情報を明記

### 親子関係の記載フォーマット
**親Epic**: [Epic名] (ID: `xxxxx`)
**親Objective**: [Objective名] (ID: `xxxxx`)
**親Spec**: [Spec名] (ID: `xxxxx`)

### タイトル命名規則
- Epic: `[Epic] 機能名`
- Objective: `[Objective] 設計名`
- Spec: `[Spec] 詳細設計名`
- Micro: `[Micro] 実装タスク名`
- 作成タスク: `Make [階層] [対象名]`
